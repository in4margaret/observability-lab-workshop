# Deploying the Application into AKS

> Goal:
>
> 1. Having the application running end-to-end and understanding the pieces.
>
> 2. Being able to observe the running application with basic "instrumentation", including emitted log lines and basic metrics. Getting familiar with out-of-the-box AKS cluster observability (e.g., workloads, pods, etc.). Checking out the Application Insights and its capabilities.

## 1. Deploy Application

Now, let's start deploying the individual services in our application. There are three components to our solution:

- Devices API: A Java application with an API that allows us to create and delete devices.
- Devices State Manager: A service which manages the state of the devices in the storage. It updates the device temperature value with the most recent one generated by the Devices Data Simulator.
- Devices Data Simulator: Simulates devices that publish their health and temperature.

> Note: make sure you have sourced the `.env` file before you continue from here.

```bash
source .env
```

```sh
az acr login --name "acr$ENV_PROJECT_NAME".azurecr.io
```

Before we start deploying the application, let's set up all the secrets in the cluster with an easy command.

```sh
make deploy_secret_store
```

We will not go into more details on how to handle secrets in a K8s cluster, as this is not the main point of this workshop. But if you are interested, we leverage the Secret Store CSI driver to pull secrets from the Key Vault resource. You can read more about this [here](https://learn.microsoft.com/en-us/azure/aks/csi-secrets-store-driver).

### Deploy: Devices API

Let's start by deploying the Devices API application. The code for this service can be found [here](https://github.com/observability-lab-cse/observability-lab/tree/section/02-deploy-application/sample-application/devices-api). It's a Java Spring Boot REST API that allows you to list, create, update, and delete devices from your device registry.

The first step is to build and push the image to the registry.

<!-- TODO: from where to run the below commands-->

```sh
TAG="v1"

cd sample-application/devices-api
docker build -t acr.azurecr.io/devices-api:$TAG .

docker tag "device-api" "acr$ENV_PROJECT_NAME.azurecr.io/devices-api"
docker push "acr$ENV_PROJECT_NAME.azurecr.io/devices-api":"$TAG"
```

Referencing this image in the deployment either below or [here](TODO)

<details markdown="1">
<summary>Click here for the Device API deployment YAML</summary>

```yaml
kind: Deployment
apiVersion: apps/v1

metadata:
  name: devices-api

spec:
  replicas: 1
  selector:
    matchLabels:
      app: devices-api
  template:
    metadata:
      labels:
        app: devices-api
    spec:
      containers:
        - name: devices-api
          image: acr${project-name}.azurecr.io/devices-api: TODO Tags
          imagePullPolicy: Always
          ports:
            - containerPort: 8080
          resources:
            requests:
              cpu: 50m
              memory: 128Mi
            limits:
              cpu: 150m
              memory: 512Mi
          volumeMounts:
            - name: secrets-store-inline
              mountPath: "/mnt/secrets-store"
              readOnly: true
          env:
            - name: AZURE_COSMOS_DB_URI
              valueFrom:
                secretKeyRef:
                  name: application-secrets
                  key: CosmosDBEndpoint
            - name: AZURE_COSMOS_DB_KEY
              valueFrom:
                secretKeyRef:
                  name: application-secrets
                  key: CosmosDBKey
            - name: AZURE_COSMOS_DB_NAME
              valueFrom:
                secretKeyRef:
                  name: application-secrets
                  key: CosmosDBName
          readinessProbe:
            httpGet:
              path: /health
              port: 8080
            periodSeconds: 20
            initialDelaySeconds: 20
            failureThreshold: 15
      volumes:
        - name: secrets-store-inline
          csi:
            driver: secrets-store.csi.k8s.io
            readOnly: true
            volumeAttributes:
              secretProviderClass: "kvprovider"


---

apiVersion: v1
kind: Service
metadata:
  name: devices-api-service
spec:
  type: LoadBalancer
  ports:
  - port: 8080
    targetPort: 8080
  selector:
    app: devices-api

```

</details>

### Deploy: Devices State Manager

Next on our agenda is the deployment of the Devices State Manager service. You can access the source code for this service [here](https://github.com/observability-lab-cse/observability-lab/tree/section/02-deploy-application/sample-application/device-manager/DeviceManager). This .NET application plays a critical role by updating the temperature records of devices in the database as data flows in from each device.

As with our previous steps, we'll need to build the image and ensure it's pushed to your Azure Container Registry (ACR).

```sh
TAG="v1"

TAG="v1"

cd sample-application/device-state-manager
docker build -t acr.azurecr.io/device-state-manager:$TAG .

docker tag "device-state-manager" "acr$ENV_PROJECT_NAME".azurecr.io/device-state-manager"
docker push "acr$ENV_PROJECT_NAME".azurecr.io/device-state-manager":"$TAG"
```

<details markdown="1">
<summary>Click here for the Device State Manager deployment YAML</summary>

```yaml
kind: Deployment
apiVersion: apps/v1

metadata:
  name: devices-state-manager

spec:
  replicas: 1
  selector:
    matchLabels:
      app: devices-state-manager
  template:
    metadata:
      labels:
        app: devices-state-manager
    spec:
      containers:
        - name: devices-state-manager
          image: acr${project-name}.azurecr.io/devices-state-manager: TODO Tags
          imagePullPolicy: Always
          ports:
            - containerPort: 8090
          resources:
            requests:
              cpu: 50m
              memory: 128Mi
            limits:
              cpu: 150m
              memory: 512Mi
          volumeMounts:
            - name: secrets-store-inline
              mountPath: "/mnt/secrets-store"
              readOnly: true
          env:
            - name: EVENT_HUB_CONNECTION_STRING
              valueFrom:
                secretKeyRef:
                  name: application-secrets
                  key: EventHubConnectionStringListen
            - name: EVENT_HUB_NAME
              valueFrom:
                secretKeyRef:
                  name: application-secrets
                  key: EventHubName
            - name: STORAGE_CONNECTION_STRING
              valueFrom:
                secretKeyRef:
                  name: application-secrets
                  key: StorageAccountConnectionString
            - name: BLOB_CONTAINER_NAME
              value: event-hub-data
            - name: DEVICE_API_URL
              value: "http://devices-api-service:8080"
      volumes:
        - name: secrets-store-inline
          csi:
            driver: secrets-store.csi.k8s.io
            readOnly: true
            volumeAttributes:
              secretProviderClass: "kvprovider"
---

apiVersion: v1
kind: Service
metadata:
  name: devices-state-manager-service
spec:
  type: LoadBalancer
  ports:
  - port: 8090
    targetPort: 8090
  selector:
    app: devices-state-manager

```

</details>

### Deploy: Devices Data Simulator

To generate data from virtual devices for testing purposes, we're deploying the device simulator, as also utilized in the [sample](TODO). This simulator effectively generates temperature data at defined intervals for each virtual device and transmits this data as messages to Event Hub.

Given we need to define how many devices we would like to simulate, you can either use the below yaml and update the device list.
Or leverage the bash script we have already created, which needs the Device API to be up and running.

```sh
make deploy-devices-simulator
```

> NOTE: Keep in mind that every time you change something in the list of your devices (e.g. Create/Delete/Update a device), the simulator needs to be restarted.

```yaml
kind: Deployment
apiVersion: apps/v1

metadata:
  name: devices-data-simulator

spec:
  replicas: 1
  selector:
    matchLabels:
      app: devices-data-simulator
  template:
    metadata:
      labels:
        app: devices-data-simulator
    spec:
      containers:
        - name: devices-data-simulator
          image: mcr.microsoft.com/oss/azure-samples/azureiot-telemetrysimulator:latest
          imagePullPolicy: Always
          resources:
            limits:
              cpu: 500m
              memory: 256Mi
            requests:
              cpu: 100m
              memory: 128Mi
          env:
            - name: EventHubConnectionString
              valueFrom:
                secretKeyRef:
                  name: application-secrets
                  key: EventHubConnectionStringSend
            - name: DeviceList
              value: "DEVICE_NAMES_PLACEHOLDER" # Specify your device names with formate `<device-1>,<device-2>,..,<device-n>`
            - name: MessageCount
              value: "0" # send unlimited
            - name: Interval
              value: "60000" # each device sends message every 1 minute
            - name: Template
              value: '{"deviceId": "$.DeviceId", "deviceTimestamp": "$.Time", "temp": $.DoubleValue}'
            - name: Variables
              value: '[{"name": "DoubleValue", "randomDouble":true, "min":20.00, "max":28.00}]'
```

## Out of the box observability

We can already have a look at what Azure will give us out of the box.

### Event Hub

<!-- TODO: go into details here -->

### AKS

<!-- TODO: go into details here -->

- Overview of pods and services
- Live logs (no history)
- AKS level metrics that are available

Now this looks all good and great. There is an awesome overview of our cluster, but other than the logs (in a, let's be honest, rather unpratical format), we have no real visibility on the application. No way to know if messages are being sent across the system, etc.
But luckily there is a simple way to fix this, which we will look at in the next chapter.

<!-- No going into insights. We will mention it exists and its limitations -->
